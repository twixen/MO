\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[utf8]{listings}
\title{\textbf{Zadanie II.9}}
\author{Damian Soliński\\
		Piotr Kulas\\
		Marek Skiba}
\date{04.12.2012}
\begin{document}

\maketitle

\section{Treść zadania}

Dla równania $f(x) = 0$, gdzie $f(x) = e^x + x + 2$, wczytać a,b $\in$ $\mathbf{R}$ takie, by $a<b$ oraz $f(a) * f(b) < 0$. Następnie, dopóki "użytkownik się nie znudzi", wczytywać wartość $0 < \epsilon < 1$ i metodą połowienia na $[a,b]$ przybliżyć z dokładnościa $\epsilon$ rozwiązanie tego równania. Rozwiązanie to przybliżyć również metodą Newtona z $x_0 = a$, przy czym $x_k$ będzie dobrym przybliżeniem, gdy $|x_k - x_(k-1)| \leq \epsilon$. Porównać ilość kroków wykonanych metodą połowienia i metodą Newtona.

\section{Schemat rozwiazywania zadania}
Najpierw pobieramy od użytkownika dwie liczby: $a$ i $b$, należące do liczb rzeczywistych, które spełniają: $a<b$ oraz $f(a) * f(b) < 0$. Następnie w pętli aż użytkownik się nie znudzi pobieramy przybliżenie ($\epsilon$) i liczymy dwoma sposobami: metodą równego podziału (metoda połowienia) oraz metodą Newtona.

\clearpage
\section*{Metoda równego podziału (metoda połowenia)}

\begin{enumerate}
  \item Sprawdzić, czy pierwiastkiem równania jest punkt $x_{1} = \frac{a+b}{2}$, czyli czy $f(x_{1}) = 0$.
  \item Jeżeli tak jest, algorytm kończy się, a punkt jest miejscem zerowym. W przeciwnym razie $x_{1}$ dzieli przedział $[a,b]$ na dwa mniejsze przedziały $[a, x_{1}]$ i $[x_{1}, b]$.
  \item Wybierany jest ten przedział, dla którego spełnione jest drugie założenie, tzn. albo $f(x_{1})f(a) < 0$ albo $f(x_{1})f(b) < 0$. Cały proces powtarzany jest dla wybranego przedziału.
\end{enumerate}

Działanie algorytmu kończy się w punkcie 2 albo po osiągnięciu żądanej dokładności przybliżenia pierwiastka.


\section*{Metoda Newtona}
W pierwszym kroku metody wybierany jest punkt startowy $x_{0}$ (w naszym wypadku wartość liczby $a$). Wyliczamy $x_{1}$ ze wzoru $x_{0} - \frac{f(x_{0})}{df(x_{0})}$. Następnie podkładamy wynik $x_{1}$ pod naszą funkcję $f(x) = e^x + x + 2$. Wynikiem funkcji będzie przybliżenie, jeśli nie jest satysfakcjonujące, wówczas punkt $x_{2}$ jest wybierany jako nowy punkt startowy i wszystkie czynności są powtarzane. Proces jest kontynuowany, aż zostanie uzyskane wystarczająco dobre przybliżenie pierwiastka.

\clearpage
\section{Przykładowe rozwiązania:} 
\section*{Metoda równego podziału (metoda połowenia)}
Ustalamy, że: $a = -3$, $b = -2$, $\epsilon = 0.01$\newline
$f(x) = e^x + x + 2$\newline
$f(a) = -0,950212932$\newline
$f(b) = 0,135335283$\newline
\newline
$x_{1} = \frac{a+b}{2} = -2.5$\newline
$f(s) = e^{-2.5} - 2.5 + 2 = -0.41791$\newline
$a = -2.5$\newline
$b = -2$\newline
$x_{1} = \frac{a+b}{2} = -2.25$\newline
$f(s) = e^{-2.25} - 2.25 + 2 = -0.144600775$\newline
$a = -2.25$\newline
$b = -2$\newline
$x_{1} = \frac{a+b}{2} = -2.125$\newline
$f(s) = e^{-2.125} - 2.125 + 2 = -0,00556703173$\newline
\newline
Osiagneliśmy oczekiwane przybliżenie, pierwiastkiem równania $f(x)$ w podanym przedziale jest $x =  -2.125$

\section*{Metoda Newtona}
Ustalamy, że: $a = -3$, $b = -2$, $\epsilon = 0.01$\newline
$f(x) = e^{x} + x + 2$\newline
$df(x) = e^{x} + 1$\newline
$x_{0} = a = -3$\newline
$x_{1} = -3 - \frac{f(-3)}{df(-3)} = -2,09485175$\newline
$f(x_{1}) = -0,950212932$\newline
$x_{2} = -2,09485175 - \frac{f(-2,09485175}{df(-2,09485175)} = -2,11999379$\newline
$f(x_{2}) = 0,000038583910$\newline
\newline
Osiagneliśmy oczekiwane przybliżenie, pierwiastkiem równania $f(x)$ w podanym przedziale jest $x= -2,11999379$

\clearpage
\section{Źródło programu:}
\lstset{language=C, basicstyle=\footnotesize, inputencoding=utf8,
literate={ą}{{\k{a}}}1 
  {Ą}{{\k{A}}}1
  {ę}{{\k{e}}}1
  {Ę}{{\k{E}}}1
  {ó}{{\'o}}1
  {Ó}{{\'O}}1
  {ś}{{\'s}}1
  {Ś}{{\'S}}1
  {ł}{{\l{}}}1
  {Ł}{{\L{}}}1
  {ż}{{\.z}}1
  {Ż}{{\.Z}}1
  {ź}{{\'z}}1
  {Ź}{{\'Z}}1
  {ć}{{\'c}}1
  {Ć}{{\'C}}1
  {ń}{{\'n}}1
  {Ń}{{\'N}}1
}

\begin{lstlisting}
#include <stdio.h>
#include <math.h>
double f(double x);
double df(double x);
void bisection(double a, double b, double e);
void newton(double x, double e);

int main() {
  double a, b, e;
  int status; 
  char chce_podac_x[2];
  do {
    printf("Podaj a: ");
    scanf("%lf", &a);
    printf("Podaj b: ");
    scanf("%lf", &b);
    if(a < b) {
      if (f(a) * f(b) < 0) {
        do {
          printf("Podaj przybliżenie: ");
          status = scanf("%lf", &e);
          if(e > 0 && e < 1) {
            bisection(a, b, e);
            newton(a, e);
          }
          do {
            printf("Chcesz podać kolejne przybliżenie? (tak/nie): ");
            scanf("%s", chce_podac_x);
            if(strcmp(chce_podac_x, "tak") == 0 || strcmp(chce_podac_x, "nie") == 0) break;
          } while(1);
        } while (strcmp(chce_podac_x, "tak") == 0);	
      } else {
        printf("błąd: f(a) i f(b) muszą mieć różny znak\n");
      }	
    } else {
      printf("błąd: a musi być mniejsze od b\n");
    }
  } while(a >= b || f(a) * f(b) >= 0);

  return 0;
}

double f(double x) {
  return exp(x) + x + 2;
}

double df(double x) {
  return exp(x) + 1;
}

void bisection(double a, double b, double e) {
  double m = (a + b) / 2;
  double fm = f(m);
  int step = 0;
  while (fabs(fm) > e) {
    if ((f(a) * fm) < 0) {
      b = m;
    } else if ((f(b) * fm) < 0) {
      a = m;
    }
    m = (a + b) / 2;
    fm = f(m);
    step += 1;
  }
  printf("Metoda połowienia:\n");
  printf("x = %.16lf, f(x) = %.16lf, Kroki: %d\n", m, fm, step);
}

void newton(double x, double e) {
  int step = 0;
  while (fabs(f(x)) > e) {
    x -= f(x) / df(x);
    step += 1;
  }
  printf("Metoda Newtona:\n");
  printf("x = %.16lf, f(x) = %.16lf, Kroki: %d\n", x, f(x), step);
}
\end{lstlisting}

\clearpage
\section{Wynik programu:}
\lstset{language=bash, basicstyle=\footnotesize, inputencoding=utf8,
literate={ą}{{\k{a}}}1 
  {Ą}{{\k{A}}}1
  {ę}{{\k{e}}}1
  {Ę}{{\k{E}}}1
  {ó}{{\'o}}1
  {Ó}{{\'O}}1
  {ś}{{\'s}}1
  {Ś}{{\'S}}1
  {ł}{{\l{}}}1
  {Ł}{{\L{}}}1
  {ż}{{\.z}}1
  {Ż}{{\.Z}}1
  {ź}{{\'z}}1
  {Ź}{{\'Z}}1
  {ć}{{\'c}}1
  {Ć}{{\'C}}1
  {ń}{{\'n}}1
  {Ń}{{\'N}}1
}

}\begin{lstlisting}
[mskiba@sigma] ~/MetodyObliczeniowe $ g++ zad2.cpp -o zad2
[mskiba@sigma] ~/MetodyObliczeniowe $ ./zad2
Podaj a: -3
Podaj b: -2
Podaj przybliżenie: 0.01
Metoda połowienia:
x = -2.1250000000000000, 
f(x) = -0.0055670317332805, 
kroki: 2.

Metoda Newtona:
x = -2.1199937939314832,
f(x) = 0.0000385795067956,
kroki: 2.

Chcesz podać kolejne przybliżenie? (tak/nie): tak
Podaj przybliżenie: 0.001
Metoda połowienia:
x = -2.1191406250000000,
f(x) = 0.0009942000281109,
kroki: 8.

Metoda Newtona:
x = -2.1199937939314832,
f(x) = 0.0000385795067956,
kroki: 2.

Chcesz podać kolejne przybliżenie? (tak/nie): nie
[mskiba@sigma] ~/MetodyObliczeniowe $
\end{lstlisting}
\end{document}
